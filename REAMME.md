
> 이것이 코딩 테스트다. (나동빈 저, 한빛미디어)
> chapter 08, 1로 만들기 문제 
> 설명 및 자세한 내용은 책을 참고해 주세요.


- DP를 생각지 않고 풀었을 대

``` java
    void test() {
		int X = 26;

		int count = 0;

			X -= 1;
			count++;

			while (X % 5 == 0) {
				X /= 5;
				count++;
			}

			while (X % 3 == 0) {
				X /= 3;
				count++;
				continue;
			}

			while (X % 2 == 0) {
				X /= 2;
				count++;
			}
	}
```

- DP를 적용한 답안 

``` java
    void test2() {
		int X = 26;
		int[] d = new int[30001];

		for (int i = 2; i <= X; i++) {
			d[i] = d[i - 1] + 1;  // 현재 index 에 대한 default

			if (i % 2 == 0) {
				d[i] = Math.min(d[i], d[i / 2] + 1);
			}
			if (i % 3 == 0) {
				d[i] = Math.min(d[i], d[i / 3] + 1);
			}
			if (i % 5 == 0) {
				d[i] = Math.min(d[i], d[i / 5] + 1);
			}
		}
	}
```

- 처음 값만 정해 놓는다면, 범위내 다른 값이 들어와도 1을 만들수 있는 최적의 답을 바로 구할 수 있다.
- 처음 1을 빼고 2로 나눈 결과값을 먼저 구하는 순서가 의미를 가지고 있었다.
  - 2에서 부터 시작, 1을 뺀 앞의 값에서 개수 추가한 경우와 2로 나누어진 계산값의 비교로 최소계산 횟수 값을 담는다.
- DP로 풀었다 생각되어도, 메모이제이션을 잘 이용하는 방향으로 설계 하지 않을 때 효율이 떨어지면서 완전 탐색 방향으로 가는 경우가 있었다.
  - 문제 풀면서 DP의 장점, 차이들을 학습해보는게 좋을 거 같다.
